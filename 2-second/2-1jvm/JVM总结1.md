# 一、内存分区
## 1.1 运行时数据区
（1）程序计数器：线程私有，记录方法执行的字节码指令地址，如果是本地方法则为空。  
（2）虚拟机栈：线程私有，Java方法的内存模型，保存方法栈帧、局部变量表、操作数栈、动态链接、方法出口。  
（3）本地方法栈：线程私有， 调用本地方法开启的栈。  
（4）堆：线程共享，几乎所有的对象都保存在堆，堆是垃圾收集器管理的区域；并不是所有的虚拟机都把堆分为新生代、  
老年代、永久的；分区只是为了更好的垃圾回收。  
（5）方法区：线程共享，保存虚拟机加载的类型信息、常量、静态变量等，可以进行垃圾回收。  
**永久代只是jdk1.8以前hotspot对于方法区的实现，1.8以后hotspot使用元数据区实现方法区**
（6）运行时常量池（属于方法区）：class文件的[常量池](#1常量池class文件资源库保存字面量和符号引用)的类容，  
类加载时候符号引用会被替换为直接引用；这些类容会被加载到运行时常量池，每个class文件都有自己的运行时常量池。  
（7）堆外内存：

## 1.2 对象
### 对象创建流程
（）检测到new指令
（）分配内存
（）<init>构造器初始化

### 对象内存分配问题：
（1）对象内存分配方式  
有指针碰撞和空闲列表两种方式，取决于堆内存空间是否规整（内存碎片）；而是否有内存碎片取决于垃圾收集算法。  
指针碰撞：分配时内存指针向空闲方向移动。  
空闲列表：一个列表维护可用的内存块。  
（2）对象分配的线程安全问题：使用CAS或本地线程分配缓冲解决。

### 对象内存布局
（1）对象头：mark word和指向类型元数据的指针构成。  
（2）实例数据：字段类容，包括从父类继承下楼的。  
（3）对齐填充：非必要。

### 对象的访问定位
《JVM规范》规定reference是指向对象的引用，访问方式主要有句柄和直接引用。  
句柄：需要维护一个句柄池，reference保存句柄地址，对象移动不影响reference，但是更慢。  
直接引用：效率更高，但是对象移动需要修改reference。

[句柄实例图](./resources/句柄.png)
[直接引用实例图](./resources/直接引用.png)

# 二、垃圾收集

## 2.1 对象已死
### 对象存活判断
引用计数、可达性分析两种算法；引用计数很难解决循环引用，主流都是使用可达性分析判断对象是否存活。  
**可达性分析算法**：以一系列"GC Roots"的跟对象为起点，向下搜索生成引用链，如果对象没有和任何引用链关联，  
则对象不再被使用，可回收。  
GC Roots集合：  
（1）虚拟机栈引用的对象；  
（2）类静态属性的引用的对象；  
（3）常量池引用的对象；  
（4）虚拟机栈引用的对象；  
（5）被synchronized持有的对象；  
（6）虚拟机内部引用，如基本数据类型的Class、常驻异常。

### 引用分类
引用：一个对象和被引用对象的这个关系称为引用，reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。
强引用：引用一直存在则一直不会被回收。  
软引用：在发生内存溢出之前，会去回收软引用指向的对象；回收后内存还不够才会抛内存溢出异常。  
弱引用：系统发生垃圾回收时，无论内存是否充足，都会被回收。  
虚引用：无法通过虚引用取得对象。

### finalize
GC扫描时若对象没有覆盖finalize方法，或者finalize方法已经被执行过，则直接回收；否则会把对象  
添加到F-Queue队列中，依次去执行finalize方法。finalize方法只会被执行一次。  
意义：可以在finalize方法中将对象重新关联上引用链，避免被回收。  
问题：F-Queue队列执行是串行的，如果某个对象的finalize方法执行死锁或缓慢，可能导致系统崩溃。

### 方法区回收
方法区可以回收废弃的常量和不再被使用的类，一般情况效益很低；在大量使用反射、CGLIB等字节码框架、  
JSP时需要虚拟机具备类卸载的功能。

### 内存泄漏
什么是内存泄漏：对象内存分配以后无法回收，对象已经不再需要了，但是引用关系还一直存在。
如下案例如果Simple一直被引用，那么object也不会被回收，但是实际object不再被使用，所以属于内存泄漏。
示例中的object应该声明为局部变量。

```
public class Simple   {
       Object object;
       void method () {
              object = new Object();
        }
}
```

## 2.2 垃圾收集算法
分代收集：大部分对象存活年龄都比较短，如果使用一种回收算法效率低；分区后，不同的区使用不同的算法；从而提高回收效率。  
标记复制：快，但是内存占用大。  
标记清除：内存使用小，但是较慢，而且有内存碎片。  
标记整理：内存使用小，没有内存碎片，但是最慢。

新生代收集：minor GC/Young GC；  
老年代收集：major GC/old GC；  
整堆收集：full GC


## 2.3 HotSpot算法细节
### 根节点枚举
找到所有的GC Roots对象， HotSpot会在对象、栈的特定位置使用OopMap结构记录下哪些位置是引用。  
为了避免在枚举的过程中引用关系的变化，根节点枚举的时候必须停顿所有用户线程。

### 安全点
HosSpot在"特定的位置"使用OopMap记录了引用信息，这些位置称为"安全点"，字节码指令流只有到了安全点  
才能暂停开始垃圾收集。发生垃圾收集时，先中断所有线程，如果中断的地方不是"安全点"，则恢复线程执行；  
知道到达"安全点"。

### 安全区域
一段代码片段引用关系不会发生变化，比如线程Blocked；当线程离开"安全区域"时如果还在进行根节点枚举将会  
被挂起，知道枚举结束。

### 记忆集和卡表
记忆集用来解决垃圾回收中"跨代引用"的问题，是一种记录非收集区域指向收集区域的数据结构。卡表是记忆集的  
一种实现方式。

### 写屏障
**和内存屏障是两码事**，写屏障用来维护卡表，理解为"引用类型赋值"这个操作的AOP，环绕通知；对引用类型  
字段的赋值操作进行拦截处理。

### 并发可达性分析
使用"三色标记"法扫描对象，进行可达性分析。  
白色：对象未被垃圾收集器访问过；  
黑色：对象的所有引用已经被收集器扫描；  
灰色：对象至少有一个引用没有被扫描。

## 2.4 垃圾收集器
可以根据收集的区域分为新生代、老年代、全区域收集器；可以分为单线程、并行收集器。

### 1.8 默认收集器
新生代使用Parallel Scavenge，老年代使用Parallel Old。
（1）Parallel Scavenge使用复制算法，是多线程并行，吞吐量优先收集器。-XX:'MaxGCPauseMillis'、  
-XX:'GCTimeRatio'设置回收停顿时间和吞吐量；-XX:UseAdaptiveSizePolicy开启，会自适应调节分区比例和大小。
（2）Parall Old使用标记整理算法，是Parallel Scavenge的老年代版本，也是吞吐量优先收集器

吞吐量：用户代码运行时间/（用户代码运行时间+垃圾收集时间）；吞吐量是整体的，对于某个时刻垃圾收集器可能  
会导致用户代码被挂起的时间过长。  
组合：CMS无法和Parallel Scavenge组合使用

### CMS收集器
使用标记清理算法，以短停顿时间为目标的收集器，称为"并发低停顿收集器"；但是有如下缺点  
（1）CPU处理器资源敏感，虽然CMS收集器在并发阶段不暂停用户线程，但是因为收集器线程会占用一部分处理器所以  
总的来说，用户程序会变慢（但是不会停顿）。  
（2）无法处理浮动垃圾（并发标记、清理时候产生的引用）；  
（3）会产生内存碎片。

### G1收集器
使用标记-复制算法，以最大收益为目标的收集器；也使用分代算法，G1将内存分为N个区域（Region），每个  
Region根据需要扮演新生代、老年代空间；G1会维护一个Region优先级队列（以回收收益排序），每次回收收益  
最大的Region。
（1）G1使用一类特殊的Region，Humongous区域保存大对象；对象超过Region一半时为大对象，G1一半会把Humongous  
区域看作老年代处理。  
（2）G1回收步骤；初始标记，并发标记，重新标记，筛选清除；除了并发标记其它步骤都需要暂停用户线程。  
（3）和CMS比较的优点；可以指定期望停顿时间，没有内存碎片，可清理浮动垃圾，Region分区效率更高等；  
（4）和CMS比较的缺点；G1内存占用更高，实现复杂运行时额外执行负载高。


### Shenandoah、ZGC
Shenandoah和ZGC都是在G1基础上，进一步优化的收集器。

## 2.5 内存分配与回收策略
（1）优先分配在Eden区域；  
（2）大对象直接进入老年代，-XX:PretenureSizeThreshold设置，**仅支持Serial、ParNew收集器**；
（3）长期存活对象进入老年代，-XX:MaxTenuringThreshold设置，默认值15；  
（4）动态年龄判定，Survivor区域相同年龄对象的大小大于空间的一半，大于这个年龄的对象进入老年代；  
（5）空间担保分配，老年代的连续空间大于"历次晋升到老年代对象的平均值"则只需执行Minor GC，否则执行Full GC。


# 三、class文件
概述：class字节码是运行在JVM上，是一个以8位（1字节）为基础单位的二进制流；Java、Scala、  
groovy等语言都可以编译为class文件。

## 3.1 文件结构
### （1）常量池，class文件资源库，保存字面量和符号引用。
### （2）访问标，类的修饰符。
### （3）类、父类、接口索引
### （4）字段表集合，字段描述信息，不包括父类字段。
### （5）方法表集合，方法描述信息。
### （6）属性表
特定场景的专有信息；Class文件、字段表、方法表都可以携带自己的属性表，比如方法的Code属性、Exceptions属性等。

## 3.2 字节码指令
字节码指令由具有特殊操作含义的操作码，以及跟随其后的操作所需参数构成。  
操作码的长度是一个字节（8位），一共有256种组合方式，所以操作吗不能超过256种；所以为了减少字节码种类，  
在编译器或运行期将byte、short、char、boolean类型数据扩展为int类型数据。

### 指令分类
（1）加载、存储指令：?load?，store
（2）算术指令
（3）类型转换指令：
（4）对象创建与操作
（5）操作数栈管理指令
（6）控制转移指令
（7）方法调用和返回指令
（8）抛出异常指令
（9）同步指令

## 补充
字面量：字符串或final修饰的常量；  
符号引用：有意义的字符串，类和接口的全限定类名，方法、字段描述符等；最终能解析、指向对应的资源。


# 四、类加载
## 4.1 加载时机
（1）遇到new、getstatic、putstatic、invokestatic指令时触发；对应的操作是实例化对象，读取或设置  
static修饰的字段（final除外），调用static修饰的方法。  
（2）反射调用。  
（3）子类初始化时，会触发父类初始化。  
（4）虚拟机启动时会初始化含main方法的类。  
（5）在使用[MethodHandle](extend.md#5methodhandle方法句柄)时，如果解析的类型是REF_getStatic，REF_putStatic，REF_invokeStatic，REF_newInvokeSpecial  
会触发目标类的初始化操作；四个类型对应的操作是获取、设置static修饰的字段，调用静态方法，调用特殊处理的实例方法（实例化方法等）。  
（6）jdk8，default修饰的接口会在其实现类初始化之前初始化。

## 4.2 类加载过程
### （1）加载
加载二进制字节流，字节流转换为方法区的运行时数据结构，并在方法区生成这个类的Class对象作为这个类的数据访问入口。  
数组类不是类加载器创建，而是由虚拟机动态构造；但数组引用类型的元素还是需要类加载器加载。

### （2）验证
验证字节流信息是否符合《JVM虚拟机规范》的约束。

### （3）准备
为静态变量分配内存，设置初始化值（系统初始值一半为0）。**"根据虚拟机规范，静态变量应该分配在方法区；但是方法区只是一个逻辑概念**  
**对于HosSpot虚拟机，在jdk8后，将静态变量和Class对象存放在了堆；可以理解保存Class对象和静态变量的这部分堆内存是实现的方法区。**

### （4）解析
将常量池的符号引用替换为直接引用。

符号引用：类和接口的全限定类名，字段、方法的名称和描述符（字符）。  
直接引用：内存入口地址，根据符号引用获取对应的class、field、method的内存地址。

### （5）初始化
执行类构造器<clinit>方法，根据程序员编码去初始化静态变量，执行静态代码块。  
<clinit>方法是自动生成的，不是必须的，父类优先执行，是线程安全的同步方法。

## 4.3 类加载器
### 类与类加载器
两个类相等，必须是由同一个类加载器加载的同一个Class文件；否则不满足相等。相等包括Class对象的equals()，isInstance()方法，instanceof关键字等。

### 双亲委派模型
概念：除了启动类加载器，加载器都有父加载器；收到加载请求时，先委托给父加载器完成，直到启动类加载器；  
当父加载器反馈无法完成时，才由当前加载器完成。  
好处：双亲委派机制使得类随着他的加载器具备了层次关系，有序性；因为最终都会调用启动类加载器，比如Object类能保证  
在各个加载器环境都是同一个类；即使自定义一个同路径的Object类，最终启动类加载器加载的也是系统自带的Object。

启动类加载器（BootstrapClassLoader）：加载\lib目录或-Xbootclasspath指定路径下，虚拟机能识别的文件名的jar包（如rt.jar，tools.jar）。  
扩展类加载器（ExtClassLoader）：\lib\ext目录下或java.ext.dirs系统变量指定的路径。  
应用程序类加载器（AppClassLoader）：加载用户路径，classpath下的类库。

### 破坏双亲委派模型
（1）兼容1.2以前的代码：因为双亲委派模型是1.2以后提出。  
（2）[SPI机制](extend.md#2spiservice-provider-interface)破坏双亲委派模型："标准服务接口"因为需要由第三方实现  
本应该由应用程序加载器加载，但是SPI机制需要由启动类加载器去加载。  
（3）tomcat破坏双亲委派机制，因为tomcat可以部署多个应用为了实现应用隔离，版本共享（当多个应用使用同一个版本的jar包时只加载一次），  
JSP加载（每个JSP文件都有属于自己的类加载器）需要破坏双亲委派。  
（3）模块化热部署破坏双亲委派机制；1.9提出的模块化系统，每个模块都有自己的类加载器。

# 五、执行引擎
## 5.1 运行时栈帧结构

## 5.2 方法调用
### 方法调用指令：
invokestatic：静态方法调用；  
invokespecial：构造器、私有的、父类方法调用；  
invokevirtual：所有虚方法调用；  
invokeinterface：接口方法调用，在运行时确定方法版本；  
invokedynamic：动态方法调用。

### 虚方法、非虚方法
非虚方法：invokestatic、invokespecial、final类型的invokevirtual指令调用的方法，既编译期确定方法版本的方法称为虚方法。  
虚方法：除了非虚方法剩下的都是虚方法。

### 方法分派
（1）静态分派：在**编译期间根据参数的静态类型**决定方法的版本称为静态分派，方法重载就是基于静态分派。  
（2）动态分派：在**运行期根据引用的实际类型**决定方法的版本称为动态分派，动态分派应用于方法重写。
（3）单分派和多分派：方法的接受者和参数统称为宗量，静态分派由方法接受者和参数决定所以是多分派；动态分派
有接受者决定，所以是单分派。**Java方法分派是静态多分派、动态单分派**

### 动态类型语言支持
（1）动态类型语言：在运行时才会进行类型检查，**变量无类型而变量值才有类型”这个特点也是动态类型语言的一个重要特征**  
比如Erlang、Groovy、JavaScript、Python、Lua、PHP等。  
（2）静态类型语言：在编译期进行类型检查，如Java、C++。  
（3）Java支持动态类型语言：因为Java是静态类型语言，invokestatic、invokespecial、invokevirtual、invokeinterface  
这四个方法调用指令所对应的**调用方法的符号引用**都是在编译期就决定了。JDK1.7引入了MethodHandle可以动态确定目标方法。  
（4）MethodHandle和反射的区别：反射也能实现在运行时确定目标方法，但是MethodHandle是字节码层次的方法调用效率更高、更
轻量（包含信息更少）**最重要的是反射只能应用于Java，MethodHandle适用于所有JVM语言。**



# 六、编译期优化
## 6.1 Javac编译器
概述：使用Java语言编写，解析、处理文件，最终生成.class字节码文件。  
编译期把我们写的代码编译为真正的class文件，像范型、装箱、拆箱这种语法糖是为了我们写代码  
的时候方便，JVM无法识别，所以编译需要对这些语法糖进行优化处理，进行自动装箱拆箱，范型的类型  
强转等。

## 6.2 范型擦除
概述：Java范型实现的方案是类型擦除，在编译的时候编译器会根据范型类型做校验；编译后的字节码为"裸类型（Raw type）"，  
编译器在需要的地方做了类型强转。

扩展：c#使用的是"具现化"范型（List<String>和List<Integer>是不同的类型），Java使用范型擦除实现范型是为了往后兼容1.5  
版本的代码。

## 6.3 自动装箱拆箱
自动装箱拆箱使用对应引用类型的方法实现，Integer.valueOf()装箱，Integer.intValue()拆箱。



# 七、运行期优化

## 7.1 解释器和即时编译器
（1）解释执行效率不高，但是占用内存少。  
（2）编译执行效率更高，但是编译成机器码后会占用更多的内存。  
（3）热点探测：通过采样或计数的方式，对方法调用和循环体进行统计，达到阈值后触发即时编译。  
（4）逃生门：即时编译优化有可能出现"逆优化"，此时即时编译失效，需要退回到解释器执行；  
所以解释器和即时编译器并存，使用解释器作为逃生门。  
（5）c1、c2编译器：hotspot的即时编译器，c1做快速的局部优化，c2做充分的高级优化。


## 7.2 公共子表达式消除
如下所示，会优化a * b，只计算一次。
```
int d = (a * b) * 6 + c + (b * a * c)
```

## 7.3 消除数组边界检查
编译器通过数据流分析，优化不需要的数组边界判断。
```

```

## 7.4 方法内联
把目标方法复制到调用方法中，避免真是的方法调用。  
非虚方法：直接内联。  
虚方法：因为虚方法在运行时分派的，具有多态选择，所以直接做方法内联可能会有冲突，不能直接内联。

### 虚方法内联：
（1）引入类型继承关系分析（CHA）技术，  
（2）如果CHA分析虚方法只有一个版本，则可以进行内联（称为守护内联）；如果后面继承关系  
发生变化，则取消内联，重新编译。  
（3）如果虚方法存在多个版本，使用内联缓存完成内联优化，既内存记录每次调用的虚方法版本，  
如果每次都调用同一个版本则进行内联，出现调用版本不一致时取消。


## 7.5 逃逸分析
逃逸分析，分为方法逃逸和线程逃逸：分析一个对象是否传递到其它方法，或被其它线程访问到；  
如果不传递给其它方法，不能被其它线程访问则表示不存在逃逸。

### 对象不会逃逸可以进行如下优化
（1）栈上分配：因为对象仅在当前方法中使用，所以无需分配到堆中，直接分配到方法栈上。  
（2）同步消除：如果一个对象只能被一个线程访问，那就不存在同步竞争，直接消除同步。  
（3）标量替换：标量是指无法再分解的最小数据，聚合量是指可以再分界的的数据；如果一个对象  
不存在逃逸，而方法中只会有一部分成员变量被使用；那么编译器可以不创建对象，只创建被使用  
到的成员变量来替换。


