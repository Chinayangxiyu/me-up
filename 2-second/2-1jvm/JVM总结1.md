# 一、内存分区
## 1.1 运行时数据区
（1）程序计数器：线程私有，记录方法执行的字节码指令地址，如果是本地方法则为空。  
（2）虚拟机栈：线程私有，Java方法的内存模型，保存方法栈帧、局部变量表、操作数栈、动态链接、方法出口。  
（3）本地方法栈：线程私有， 调用本地方法开启的栈。  
（4）堆：线程共享，几乎所有的对象都保存在堆，堆是垃圾收集器管理的区域；并不是所有的虚拟机都把堆分为新生代、  
老年代、永久的；分区只是为了更好的垃圾回收。  
（5）方法区：线程共享，保存虚拟机加载的类型信息、常量、静态变量等，可以进行垃圾回收。  
**永久代只是jdk1.8以前hotspot对于方法区的实现，1.8以后hotspot使用元数据区实现方法区**
（6）运行时常量池（属于方法区）：class文件的[常量池](#1常量池class文件资源库保存字面量和符号引用)的类容，  
类加载时候符号引用会被替换为直接引用；这些类容会被加载到运行时常量池。  
（7）堆外内存：

## 1.2 对象
### 对象创建流程
（）检测到new指令
（）分配内存
（）<init>构造器初始化

### 对象内存分配问题：
（1）对象内存分配方式  
有指针碰撞和空闲列表两种方式，取决于堆内存空间是否规整（内存碎片）；而是否有内存碎片取决于垃圾收集算法。  
指针碰撞：分配时内存指针向空闲方向移动。  
空闲列表：一个列表维护可用的内存块。  
（2）对象分配的线程安全问题：使用CAS或本地线程分配缓冲解决。

### 对象内存布局
（1）对象头：mark word和指向类型元数据的指针构成。  
（2）实例数据：字段类容，包括从父类继承下楼的。  
（3）对齐填充：非必要。

### 对象的访问定位
《JVM规范》规定reference是指向对象的引用，访问方式主要有句柄和直接引用。  
句柄：需要维护一个句柄池，reference保存句柄地址，对象移动不影响reference，但是更慢。  
直接引用：效率更高，但是对象移动需要修改reference。

[句柄实例图](./resources/句柄.png)
[直接引用实例图](./resources/直接引用.png)

# 二、垃圾收集

## 2.1 对象已死
### 对象存活判断
引用计数、可达性分析两种算法；引用计数很难解决循环引用，主流都是使用可达性分析判断对象是否存活。  
**可达性分析算法**：以一系列"GC Roots"的跟对象为起点，向下搜索生成引用链，如果对象没有和任何引用链关联，  
则对象不再被使用，可回收。  
GC Roots集合：  
（1）虚拟机栈引用的对象；  
（2）类静态属性的引用的对象；  
（3）常量池引用的对象；  
（4）虚拟机栈引用的对象；  
（5）被synchronized持有的对象；  
（6）虚拟机内部引用，如基本数据类型的Class、常驻异常。

### 引用分类
强引用：引用一直存在则一直不会被回收。  
软引用：在发生内存溢出之前，会去回收软引用指向的对象；回收后内存还不够才会抛内存溢出异常。  
弱引用：系统发生垃圾回收时，无论内存是否充足，都会被回收。  
虚引用：无法通过虚引用取得对象。

### finalize
GC扫描时若对象没有覆盖finalize方法，或者finalize方法已经被执行过，则直接回收；否则会把对象
添加到F-Queue队列中，依次去执行finalize方法。finalize方法只会被执行一次。  
意义：可以在finalize方法中将对象重新关联上引用链，避免被回收。  
问题：F-Queue队列执行是串行的，如果某个对象的finalize方法执行死锁或缓慢，可能导致系统崩溃。

### 方法区回收
方法区可以回收废弃的常量和不再被使用的类，一般情况效益很低；在大量使用反射、CGLIB等字节码框架、  
JSP时需要虚拟机具备类卸载的功能。


## 2.2 垃圾收集算法
分代收集：大部分对象存活年龄都比较短，如果使用一种回收算法效率低；分区后，不同的区使用不同的算法；从而提高回收效率。  
标记复制：快，但是内存占用大。  
标记清除：内存使用小，但是较慢，而且有内存碎片。  
标记整理：内存使用小，没有内存碎片，但是最慢。

新生代收集：minor GC/Young GC；  
老年代收集：major GC/old GC；  
整堆收集：full GC


## 2.3 HotSpot算法细节
### 根节点枚举
找到所有的GC Roots对象， HotSpot会在对象、栈的特定位置使用OopMap结构记录下哪些位置是引用。  
为了避免在枚举的过程中引用关系的变化，根节点枚举的时候必须停顿所有用户线程。

### 安全点
HosSpot在"特定的位置"使用OopMap记录了引用信息，这些位置称为"安全点"，字节码指令流只有到了安全点  
才能暂停开始垃圾收集。发生垃圾收集时，先中断所有线程，如果中断的地方不是"安全点"，则恢复线程执行；  
知道到达"安全点"。

### 安全区域
一段代码片段引用关系不会发生变化，比如线程Blocked；当线程离开"安全区域"时如果还在进行根节点枚举将会  
被挂起，知道枚举结束。

### 记忆集和卡表
记忆集用来解决垃圾回收中"跨代引用"的问题，是一种记录非收集区域指向收集区域的数据结构。卡表是记忆集的  
一种实现方式。

### 写屏障
**和内存屏障是两码事**，写屏障用来维护卡表，理解为"引用类型赋值"这个操作的AOP，环绕通知；对引用类型  
字段的赋值操作进行拦截处理。

### 并发可达性分析
使用"三色标记"法扫描对象，进行可达性分析。  
白色：对象未被垃圾收集器访问过；  
黑色：对象的所有引用已经被收集器扫描；  
灰色：对象至少有一个引用没有被扫描。

## 2.4 垃圾收集器
可以根据收集的区域分为新生代、老年代、全区域收集器；可以分为单线程、并行收集器。

### 1.8 默认收集器
新生代使用Parallel Scavenge，老年代使用Parallel Old。
（1）Parallel Scavenge使用复制算法，是多线程并行，吞吐量优先收集器。-XX:'MaxGCPauseMillis'、  
-XX:'GCTimeRatio'设置回收停顿时间和吞吐量；-XX:UseAdaptiveSizePolicy开启，会自适应调节分区比例和大小。
（2）Parall Old使用标记整理算法，是Parallel Scavenge的老年代版本，也是吞吐量优先收集器

吞吐量：用户代码运行时间/（用户代码运行时间+垃圾收集时间）；吞吐量是整体的，对于某个时刻垃圾收集器可能  
会导致用户代码被挂起的时间过长。  
组合：CMS无法和Parallel Scavenge组合使用

### CMS收集器
使用标记清理算法，以短停顿时间为目标的收集器，称为"并发低停顿收集器"；但是有如下缺点  
（1）CPU处理器资源敏感，虽然CMS收集器在并发阶段不暂停用户线程，但是因为收集器线程会占用一部分处理器所以  
总的来说，用户程序会变慢（但是不会停顿）。  
（2）无法处理浮动垃圾（并发标记、清理时候产生的引用）；  
（3）会产生内存碎片。

### G1收集器
使用标记-复制算法，以最大收益为目标的收集器；也使用分代算法，G1将内存分为N个区域（Region），每个  
Region根据需要扮演新生代、老年代空间；G1会维护一个Region优先级队列（以回收收益排序），每次回收收益  
最大的Region。
（1）G1使用一类特殊的Region，Humongous区域保存大对象；对象超过Region一半时为大对象，G1一半会把Humongous  
区域看作老年代处理。  
（2）G1回收步骤；初始标记，并发标记，重新标记，筛选清除；除了并发标记其它步骤都需要暂停用户线程。  
（3）和CMS比较的优点；可以指定期望停顿时间，没有内存碎片，可清理浮动垃圾，Region分区效率更高等；  
（4）和CMS比较的缺点；G1内存占用更高，实现复杂运行时额外执行负载高。


### Shenandoah、ZGC
Shenandoah和ZGC都是在G1基础上，进一步优化的收集器。

## 2.5 内存分配与回收策略
（1）优先分配在Eden区域；  
（2）大对象直接进入老年代，-XX:PretenureSizeThreshold设置，**仅支持Serial、ParNew收集器**；
（3）长期存活对象进入老年代，-XX:MaxTenuringThreshold设置，默认值15；  
（4）动态年龄判定，Survivor区域相同年龄对象的大小大于空间的一半，大于这个年龄的对象进入老年代；  
（5）空间担保分配，老年代的连续空间大于"历次晋升到老年代对象的平均值"则只需执行Minor GC，否则执行Full GC。


# 三、class文件
概述：class字节码是运行在JVM上，是一个以8位（1字节）为基础单位的二进制流；Java、Scala、  
groovy等语言都可以编译为class文件。

## 3.1 文件结构
### （1）常量池，class文件资源库，保存字面量和符号引用。
### （2）访问标，类的修饰符。
### （3）类、父类、接口索引
### （4）字段表集合，字段描述信息，不包括父类字段。
### （5）方法表集合，方法描述信息。
### （6）属性表
特定场景的专有信息；Class文件、字段表、方法表都可以携带自己的属性表，比如方法的Code属性、Exceptions属性等。

## 3.2 字节码指令
字节码指令由具有特殊操作含义的操作码，以及跟随其后的操作所需参数构成。  
操作码的长度是一个字节（8位），一共有256种组合方式，所以操作吗不能超过256种；所以为了减少字节码种类，  
在编译器或运行期将byte、short、char、boolean类型数据扩展为int类型数据。

### 指令分类
（1）加载、存储指令：?load?，store
（2）算术指令
（3）类型转换指令：
（4）对象创建与操作
（5）操作数栈管理指令
（6）控制转移指令
（7）方法调用和返回指令
（8）抛出异常指令
（9）同步指令

## 补充
字面量：字符串或final修饰的常量；  
符号引用：有意义的字符串，类和接口的全限定类名，方法、字段描述符等；最终能解析、指向对应的资源。


# 四、类加载
## 4.1 加载时机
（1）遇到new、getstatic、putstatic、invokestatic指令时触发；对应的操作是实例化对象，读取或设置  
static修饰的字段（final除外），调用static修饰的方法。  
（2）反射调用。  
（3）子类初始化时，会触发父类初始化。  
（4）虚拟机启动时会初始化含main方法的类。  
（5）在使用[MethodHandle](extend.md#5methodhandle方法句柄)时，如果解析的类型是REF_getStatic，REF_putStatic，REF_invokeStatic，REF_newInvokeSpecial  
会触发目标类的初始化操作；四个类型对应的操作是获取、设置static修饰的字段，调用静态方法，调用特殊处理的实例方法（实例化方法等）。  
（6）jdk8，default修饰的接口会在其实现类初始化之前初始化。

## 4.2 类加载过程
### （1）加载
加载二进制字节流，字节流转换为方法区的运行时数据结构，并在方法区生成这个类的Class对象作为这个类的数据访问入口。  
数组类不是类加载器创建，而是由虚拟机动态构造；但数组引用类型的元素还是需要类加载器加载。

### （2）验证
验证字节流信息是否符合《JVM虚拟机规范》的约束。

### （3）准备
为静态变量分配内存，设置初始化值（系统初始值一半为0）。**"根据虚拟机规范，静态变量应该分配在方法区；但是方法区只是一个逻辑概念**  
**对于HosSpot虚拟机，在jdk8后，将静态变量和Class对象存放在了堆；可以理解保存Class对象和静态变量的这部分堆内存是实现的方法区。**

### （4）解析
将常量池的符号引用替换为直接引用。

符号引用：类和接口的全限定类名，字段、方法的名称和描述符（字符）。  
直接引用：内存入口地址，根据符号引用获取对应的class、field、method的内存地址。

### （5）初始化
执行类构造器<clinit>方法，根据程序员编码去初始化静态变量，执行静态代码块。  
<clinit>方法是自动生成的，不是必须的，父类优先执行，是线程安全的同步方法。

## 4.3 类加载器
### 类与类加载器
两个类相等，必须是由同一个类加载器加载的同一个Class文件；否则不满足相等。相等包括Class对象的equals()，isInstance()方法，instanceof关键字等。

### 双亲委派模型
概念：除了启动类加载器，加载器都有父加载器；收到加载请求时，先委托给父加载器完成，直到启动类加载器；  
当父加载器反馈无法完成时，才由当前加载器完成。  
好处：双亲委派机制使得类随着他的加载器具备了层次关系，有序性；因为最终都会调用启动类加载器，比如Object类能保证  
在各个加载器环境都是同一个类；即使自定义一个同路径的Object类，最终启动类加载器加载的也是系统自带的Object。

启动类加载器（BootstrapClassLoader）：加载\lib目录或-Xbootclasspath指定路径下，虚拟机能识别的文件名的jar包（如rt.jar，tools.jar）。  
扩展类加载器（ExtClassLoader）：\lib\ext目录下或java.ext.dirs系统变量指定的路径。  
应用程序类加载器（AppClassLoader）：加载用户路径，classpath下的类库。

### 破坏双亲委派模型
（1）兼容1.2以前的代码：因为双亲委派模型是1.2以后提出。  
（2）[SPI机制](extend.md#2spiservice-provider-interface)破坏双亲委派模型："标准服务接口"因为需要由第三方实现  
本应该由应用程序加载器加载，但是SPI机制需要由启动类加载器去加载。  
（3）模块化热部署破坏双亲委派机制；1.9提出的模块化系统，每个模块都有自己的类加载器。

# 五、执行引擎

# 六、编译期优化

# 七、运行期优化

