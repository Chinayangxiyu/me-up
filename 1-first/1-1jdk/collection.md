# 1、ArrayList
    概述:底层结构是数组,默认初始长度为10
    扩容机制:添加元素elements.size的长度>size的0.5,则扩容长度为elements.size + size;否则size = size + 0.5 * size;
    查询复杂度:根据索引查询 O(1);
    允许元素为null;
    
#2、LinkedList
    概述:实现了接口Deque,双端链表,默认add操作是添加在链表尾部,查询时需要遍历.
    查询复杂度:O(n)
    允许元素为null;
    
#3、HashMap
        概述：底层接口是数组 + (链表 || 红黑树);元素存链表还是红黑树由哈希冲突的长度实现，默认值是8；查询的适合根据hash值、key对象地址、
    key对象equals()方法判断是否为同一个对象。
        扩容机制：当已添加的数组元素达到加载因子值（默认0.75），以2的N次幂进行扩容，因为（2的N次幂-1）的二进制每一位都是1，能够降低哈希  
    冲突，使得元素分布更均匀；HashMap在计算当前元素属于数组哪个索引的时候，会把插入元素的哈希值 和 数组长度减一做与运算（int n = hash &  
     length - 1），运算结果n就是索引。如果数组的长度为2的倍数扩容，那么 length - 1的最后几位永远是 ***1111，做&位运算能分布更均匀。 举例  
     如果数组长度为15， length -1 转为二进制 = 1110。如果有两个元素的哈希值为8、9。转为二进制分别是1000，1001。1000 & 1110 = 1000，1001   
     & 1110 = 1000，运算的结果一致，产生了哈希冲突。  
        查询复杂度：不存在哈希冲突，链表元素为1，复杂度是O(1)；最坏的情况如果Entry存的是链表，且查询的元素在链表尾部，复杂度为O(n)；最坏  
    的情况如果Entry存的是红黑树，复杂度为log(n)
        jdk1.8的优化：扩容的时候需要将链表遍历拷贝到新的数组，遍历时从头节点开始的，1.8以前产生hash冲突，添加链表的时候采用头结点插入，  
    链表的顺序会颠倒一次，因为HashMap不是线程安全的，当产生并发的时候可能会出现死链。1.8优化后，使用尾节点插入，不会颠倒链表顺序，不会
    产生死链。
        1.7死链描述：链表[A,B,C,D]，复制的时候采用头节点插入，先复制A节点，然后设置A的pre节点，此时线程并发，线程1获取到A的next是B，将B
    设置为A的pre节点；此时线程2获取节点B的next 已经指向了节点A；最后设置B节点的pre时会设置为A。最终，形成死链。
    
**hashCode()方法保证相同的输入得到相同的输出，不保证不同的输入有不同的输出**  
**equals()是判断两个对象是否相等**
    
        