# 一、布隆过滤器
概述：一个二进制数组a，默认值都是0，通过多次哈希计算，将一个值"x"每次哈希计算的结果作为a的索引\[5,7,8\]；标记为1；  
现在判断一个值"y"是否已经存在，将这个值同样经过多次哈希计算得到结果\[5,8,9\]，现在数组a索引为9的值是0，说明"y"是肯定  
不存在的。**布隆过滤器用于判断一个值肯定不存在，或有可能存在；不能判断一个值肯定存在**  
关键点：  
（1）哈希算法：影响布隆过滤器性能，[哈希算法](https://blog.csdn.net/weixin_34308389/article/details/92487414)  
（2）位数组长度：影响错误率。[位数组长度](https://blog.csdn.net/ttaannkkee/article/details/102502921)  
现成的轮子
```
        <!-- -->
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>21.0</version>
        </dependency>
```

# 二、JWT
[参考](https://www.zhihu.com/collection/525744206)
## 2.1 概念
什么是jwt：JSON Web Token，开放标准(RFC 7519)；是一种Web令牌，定义了一种紧凑的JSON结构信息，经过加密后在各系统之间传递。

## 2.2 结构：JWT包含3个部分：头部Header，数据Payload，签名Signature。
###  Header属性
alg：算法
type：令牌类型，统一写JWT
### payload属性：iss (issuer)：签发人
exp (expiration time)：过期时间
sub (subject)：主题
aud (audience)：受众
nbf (Not Before)：生效时间
iat (Issued At)：签发时间
jti (JWT ID)：编号

## 2.3 工作原理：
背景概述：有一个统一的用户管理中心，所以的前端页面系统和这个用户中心交互拿到用户信息；后端服务并不直接和用户管理中心交互。
1、登陆：用户在前端页面登陆，调用用户管理中心进行校验，
2、生成token：用户管理中心校验通过以后，将需要的信息添加到JWT中的 payload，然后加密；生成token返回给前端
3、访问后端服务：前端拿到token后，根据这个token访问后端服务；
4、解析：后端服务解析前端给的JWT，获取到自己想要的信息；并判断token是否失效(时间)等条件，确定是否能继续访问。

## 2.4 JWT优劣势（和传统sessionID比较）
优势：实现简单，后端服务和用户管理中心解偶

劣势：  
&emsp;&emsp;  （1）加密解密需要消耗时间和资源；
&emsp;&emsp;  （2）交互的过程中token数据比sessionID大，占用更多宽带；
&emsp;&emsp;  （3）虽然JWT自身带有失效时间，但是不能主动使其失效；既不能主动注销用户的访问。

优势：
&emsp;&emsp;  （1）无状态：后端不需要像session一样存储信息，但是无状态也导致系统无法强制使JWT失效；
使用JWT访问服务的任何一个节点都可以，但是使用session的话还需要验证session是否生效等。
&emsp;&emsp;  （2）不依赖cookie：sessionID的传递依赖cookie，token不依赖；
&emsp;&emsp;  （3）跨语言：因为token是json结构，可以跨语言通用。


# 三、序列化
数据在传输的过程中需要按照一定的结构进行序列化，接收方需要反序列化。
java常用的序列化框架：jdk自带序列化、FastJson、hessian、kryo、protobuf等。
序列化框架实现原理。

## 3.1 jdk自带序列化
基于ObjectInputStream和ObjectOutputStream实现的序列化，只能序列化实现了Serializable  
接口的类；序列化和反序列化的serialVersionUID必须相同。

### 缺陷
（1）无法跨语言；
（2）有安全风险，反序列化可以执行任意类型的代码；
（3）序列化后的二进制流太大，存储增加、占用带宽增加，影响吞吐量；
（4）序列化性能差。

## 3.2 Json序列化
Jackson：格式不标准
Fastjson：通用、性能好；经常有漏洞
Gson：功能强大，性能低于FastJson


## 3.3 hessian
支持跨语言
性能高于jdk，但还是不高

## 3.4 Kryo
高性能，比hessian还高
不向前、向后兼容；跨语言复杂

## 3.5 protobuf
跨语言，更快、更小、更便捷，但是需要按照环境。


# 四、本地缓存
空间换时间，每个节点都保存缓存数据以提升访问速度，常用于热点数据的访问。

## 4.1 Ehcache
比Guava Cache性能更高
## 4.2 Guava Cache

# 五、加密算法
加密算法分类：单向加密（Hash算法）、对称加密和非对称加密。

## 5.1 单向加密
特征：不可逆、输入一样，输出必然相同、定长输出。  
补充：会有散列冲突（hash冲突）问题，常用于信息传输完整性校验（验签）。  
常见算法：MD5、SHA、CRC-32

## 5.2 对称加密
特征：加密和解密的密钥一致，不安全。  
常见算法：DES、3DES、AES

## 5.3 非对称加密
特征：加密和解密的密钥不一致，安全。  
RSA、ECC、DSA
