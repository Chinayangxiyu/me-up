# 一、索引


## 索引优化
### 覆盖索引
索引包含的字段就是查询需要的字段，那么就不需要做回表查询，直接从普通索引返回数据。

### 优化器不使用索引
因为普通索引需要做回表查询，或可选范围过低时；优化器感觉使用索引的效率低于不使用索引，  
则不会使用索引。

### MRR（Multi range read）优化
普通索引做回表查询时，将普通索引结果返回的主键排序后，再去主键索引查。

### ICP（Index Condition Pushdown）优化
5.6以前不支持，查询的时候是先根据索引查到数据，然后根据where条件去过滤；  
使用索引下推优化后，在使用索引查数据时就使用where条件过滤数据，减少了返回结果集。


## 执行计划
### 执行计划包含如下信息：
     id：执行select子句或操作表的顺序，id大的优先级高，id一致从上到下。  
     select_type：查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。  
     table：显示这一行的数据是关于哪张表的。  
     type：查询使用的类型，从最好到最差依次是：system>const>eq_ref>ref>range>index>ALL。一般来说，得保证查询至少达到range级别，最好能达到ref。
     possible：显示可能应用在这张表中的索引，一个或多个。
     key：实际使用的索引。如果为NULL，则没有使用索引。
     key_len：索引字段的最大可能长度，并非实际使用长度。
     ref：哪些列或常量被用于查找索引列上的值。
     rows：大致估算找到所需的记录所需要读取的行数。
     Extra：不适合在其他列中显示但十分重要的额外信息，执行语句的后对效率进行的描述信息。

Extra
Using filesort:需要额外的一次排序操作才能完成查询
Using index:代表优化器使用了覆盖索引操作
Using intersect(b,a):表示两个索引得到的结果进行求交运算
Using Condition Pushdown:优化器选择了Index Condition Pushdown(ICP索引下推)优化
Using Where：回表查询。
Using index condition：5.6加入的新特性，
Select tables optimized away:优化极限，比如select max(version) FROM  pub_loan_img_rule  	         version配有索引。

### optimizer trace
explain只能看见执行计划的基础信息；使用optimizer trace可以获取执行语句的解析、优化过程；
做更细致的跟踪分析，然后去优化。

使用方式：

## 怎么创建索引
### 1、主键避免使用UUID
因为UUID是无序、无规律的；有可能后面插入的UUID比之前的值小，所以数据需要插入到聚簇索引中间  
的位置；从而导致页分裂，大量移动数据，并且页数据变得稀松并被不规则的填充，产生碎片。而使用自增  
主键或雪花算法生成的ID时，因为是有序的，每次直接添加在聚簇索引所有的最后一个节点，效率更高。

页分裂：B+树每个节点是一个Leaf page保存多个值（链表），index page是叶子节点；当主键是有序的时候  
聚簇索引索引的页数据都是饱满的、规律的；当插入无序主键时会破坏聚簇索引的这种状态。  
自增ID：自增ID有锁的争用，在并发高的场景下会有性能损失。一般使用雪花算法创建主键。


### 2、索引字段的区分度
Cardinality可以判断索引的区分度，通过采样叶子节点获取索引的区分度（所以是一个预估值）；  
区分度过低会导致返回的数据集过大，所以区分度值过小时会导致索引时效。  
show index from table可以查看表索引的区分度。

### 3、排序字段创建索引
因为索引是有序的，所以当order by column字段和索引字段匹配的话，查询效率会更高；  
否则存储引擎需要执行一次额外的排序才能完成查询。


## 怎么写高性能的查询sql
### 1、使用覆盖索引
有可能的话，查询的结果字段和索引包含的字段保持一致，从而使用覆盖索引查询。

### 2、联合索引
对于联合索引注意满足左前缀匹配原则。

### 3、"首个where"条件返回的结果集最小化
（1）如果查询where条件不包含索引，那么以第一个where条件返回的结果集；
（2）如果包含索引，第一个索引条件返回结果集尽量最小。




# 二、事务
## 事务的ACID特性
（1）原子性
（2）一致性
（3）隔离性
（4）持久性

补充：redo log实现原子性和持久性；undo log（回滚）实现了一致性；事务的"串行化"隔离级别
保证了事务的隔离性。


## 事务的隔离级别
（1）读未提交：存在脏读；  
（2）读已提交：存在不可重复读，同一个事务内其它事务提交两次，那么当前事务两次读取可能不一样；  
（3）可重复读：存在幻读，两次读取的行数不同count；  
（4）串行化：保证隔离性。

说明：InboDB使用MVCC解决不可重复读的问题；使用Next-KeyLock算法解决幻读问题。所以  
InnoDB的默认隔离级别"可重复读"完全保证了事务的隔离性；达到了串行化的标准。


## redo undo
### redo原理
概述：事务commit时会将本次事务的操作日志写到redo log（重做日志文件）保证原子性和持久性。


### undo
#### 概述：
对数据库修改时会产生undo，undo log也会产生redo log，既undo log也需要持久化保护。

#### 功能
（1）回滚：undo是逻辑日志，回滚的时候执行的是逻辑恢复；insert的回滚操作是delete，delete的回滚操作是insert，  
update的回滚操作是反向的update；**逻辑恢复是指数据的业务逻辑回滚到了事务之前的样子，但是表的物理文件和事务提交之前已经不同了。**  
（2）为InnoDB的MVCC提供支持：当读的某一行数据被其它事务占用时，当前事务可以通过undo读之前的版本信息。

事务提交时会把undo log放入一个链表，最终是否删除有purge线程判断。

#### undo log分类：
（1）insert undo log：因为insert操作只对本事务可见（隔离性要求），所以事务提交后直接删除insert undo log；
（2）update undo log：分为delete操作和update操作，delete操作并不直接删除数据，而是将记录标记为已删除；
update操作是先将原记录标记为删除，然后插入一条新的记录。

#### purge线程
事务提交后update、delete操作并不直接修改原数据，使用purge最终完成delete、update操作；
因为InnoDB支持MVCC，事务提交的时候可能其它事务正在引用当前行，所以不能立即处理。


## MVCC
多版本并发控制，解决读-写冲突的无锁并发控制（不可重复读问题）；实现并发事务，提高数据库并发性能。  
### 实现MVCC关键点；
（1）隐藏字段：DB_TRX_ID（事务ID），DB_ROLL_PTR（回滚指针，这行记录上一个版本），  
delete_flag（删除标记），DB_ROW_ID（未创建主键时，默认创建的主键）。  
（2）undo，每个事务都有一个版本号，每一行数据已提交的事务会根据版本号生成一个链状结构的数据，  
因此事务提交后并没有立即处理，而是交给purge线程去处理；  
（3）Read View（读视图），事务在进行快照读操作时，会根据当前事务ID，生成一个当前事务能读取的  
最新数据的视图。

处理流程：事务在开启快照读的时候，会根据当前事务ID去找到所能读到的最新版本（已提交的事务ID < 当前事务ID）的数据，

## 快照读和当前读
当前读：并发事务时会加锁，每次都是读取的最新的数据；性能低。  
快照读：不加锁的非阻塞读，读取的可能是已提交事务的某个历史版本。


## B树、B+树
B+树对于B树做了改进，


# 三、创建索引的注意事项（源自阿里 《Java开发手册》）
（1）唯一的字段必须创建索引；
（2）join表的字段必须创建索引；
（3）varchar字段创建索引时需要指定索引长度，因为varchar不是定长字段，如果不指定长度
索引文件过大，影响查询速度，而且一般长度为20的索引，区分度也能达到90%以上。
（4）禁止左模糊、全模糊查询，需要可使用搜索引擎；左模糊和全模糊会导致索引失效。
（5）order by场景可以为排序字段创建索引；这样排序字段所在索引本身就是有序的 比年file sort情况。
（6）利用覆盖索引，避免回表查询。
（7）执行计划，索引的type类型至少应该达到 type。
（8）组合索引区分度最高的在左边。


# 四、SQL语句书写注意事项
（1）

为什么不推荐使用子查询：因为子查询会创建临时表，查询后会删除，消费性能。
为什么不推荐使用join：因为mysql的join是通过驱动表的结果集，一条一条过滤，最后合并结果；当数据量过大或者join的表过多时性能下降明显。


