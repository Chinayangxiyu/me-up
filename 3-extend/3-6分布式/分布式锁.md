# 一、分布式锁
## 1.1 分布式锁的实现方式
（1）redis使用添加了过期时间的key实现；  
（2）zk使用临时节点实现；  
（3）基于数据库实现（不专业）；  
（4）基于paxos算法的分布式锁服务Google Chubby。

总结：分布式锁就是维护一个分布式系统能够共享的变量。

## 分布式锁实现需要注意的问题
（1）死锁问题，锁一直得不到释放，影响系统运行。  
（2）原子性问题，无法保证原子性锁的获取、释放会无序。  
（3）一致性问题，

# 二、redis实现分布式锁
## 原理
使用redis hash key实现分布式锁。  
（1）为key添加过期时间，避免死锁。  
（2）使用uuid避免错误的释放锁，因为redis服务器在进行数据同步时可能会有数据丢失，当  
thread1加锁的key丢失后业务在继续执行，此时thread2可以成功获取锁，如果此时thread1
业务执行结束后去释放锁，**如果没有uuid的判断**会错误的释放掉thread2添加的锁。  
（3）获取锁的时候使用setnx命令；因为加锁时使用了uuid，释放锁的时候需要先获取uuid进行  
判断，再执行删除（先get，再del）；这两步操作不是原子的，所以释放锁需要使用lua表达式保  
证原子性。  
（4）使用看门狗机制延长锁过期时间，保证业务执行时间异常时的整除运行；实现原理是开启一  
个监视线程watch dog定期去续约。  
（5）使用redis哈希对象可以实现重入锁机制，value保存int类型的重入次数。
（6）获取锁时候，使用while循环、线程等待。

# 三、zookeeper实现分布式锁
使用zk临时节点实现分布式锁。  
（1）zk在创建Znode数据时，多个客户端只会一个创建成功（所有的请求都是由leader处理的）；
（2）临时节点的存在是基于会话的，所以不存在死锁问题；redis死锁问题是应用加锁后应用在
未释放锁的情况下崩溃，然后就无法释放锁了，但是zk临时节点锁基于会话的，应用崩溃后临时
节点会自动删除，锁自动释放。
（3）zk可以使用基于顺序临时节点实现读写锁


# 四、Google Chubby分布式锁服务

