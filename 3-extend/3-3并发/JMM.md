# 一、

JMM：Java内存模型
顺序性模型：理想模型，无重排序
happens-before：先行发生原则，判断Java执行的顺序性原则，否则需要理解底层原理

缓存一致性协议：保障处理器的缓存一致，IA-32处理器和Intel 64处理器使用MESI实现缓存一致性协。



# JMM简述
JMM是Java线程的内存模型，共享变量属于主内存（堆中对象的属性等），每个线程都有自己的  
工作内存，工作内存会缓存共享变量的副本并有写缓存，线程直接的通信通过读写主内存变量实现。


JMM是围绕并发过程如何处理原子性、可见性、有序性建立的。

## 工作内存和主内存间的操作
JMM定义了8种操作
作用于主内存：lock、unlock、read、write  
作用于工作内存：load、use、assign、store

## 原子性、可见性、顺序性问题
原子性问题：某个写操作无法保证原子性，写到一半的时候被其它线程读取，导致读到了错误的结果。
可见性问题：一个线程更新一个变量后，其它线程不能立刻知道。
有序性问题：因为存在指令重排序、处理器存在写缓冲区的原因，指令的执行实际执行的顺序和
写的程序执行顺序不一致；在并发的情况下因为工作内存存在缓冲区，一个线程观测其它的执行
顺序都是乱序的。


## JMM保证原子性、可见性、顺序性

### 原子性
（1）JMM定义的read、load、use、assign、store、write这些基本操作是原子的。
（2）对于应用场景使用synchronized保证原子性，其底层也是调用的lock、unlock操作。

### 可见性
（1）使用volatile关键字的特性保证线程之间的可见性。
（2）使用synchronized保证更大粒度的可见性，因为在执行unlock之前需要将所有变量刷回主内存。
的应用场景使用synchronized（底层使用lock、unlock指令）保证原子性。
可见性：volatile关键字的特性保证了可见性，synchronized

### 有序性
（1）volatile保证有序性，原理是内存屏障；
（2）synchronized保障有序性，因为临界区同时只有一个线程进入。



## 深入理解volatile
