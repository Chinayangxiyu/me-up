# 一、上下文切换
## 1.1、上下文切换：
CPU通过时间片循环执行程序，时间片执行结束时会保存当前任务的执行状态，下一次分配到时间片的时候，重新加载任务；  
一次线程任务的保存到加载的过程，就是"线程上下文切换"；以下场景会发生上下文切换。  
（1）、CPU时间片执行结束，调度下一个任务；  
（2）、中断处理；  
（3）、用户态切换；  
（4）、锁资源抢占。


## 1.2、减少上下文切换
无锁并发编程：分段式锁，不同的线程处理不同段，比如（jdk1.7 ConcurrentHashMap的分段式锁）。  
CAS算法：避免锁资源抢占。  
使用最少线程：避免创建过多的线程；使用线程池，控制并发数。  
协程：在但线程实现多任务的调度、切换。

## 1.3、避免死锁
避免一个线程获取多个锁，占用多个共享资源。  
尝试使用定时锁。  
数据库锁，加锁和解锁保证在同一个连接。

## 1.4 java线程中断
### 概述
 Java线程中断是给线程添加了一个中断标记。线程中断有如下作用：  
（1）优雅地关闭线程，弃用的stop方法在关闭的时候导致线程任务突然终止，可能导致某些资源（IO）  
没有回收；而外部调用中断操作后，线程任务内部主动识别中断状态，可以在合适的时候终止任务。  
（2）中断标记可以作为线程间通信的媒介，任务在执行的过程中判断中断状态；其它线程通过调用  
目标线程的interrupt（）标记中断完成通信；而目标线程在任务执行过程中随时去检测中断状态，完成对中断的响应。  
比如AQS中响应中断操作就是在加锁过程中判断中断状态，如果被中断则抛出InterruptedException异常。

### 线程状态对中断操作的反应
（1）运行时（Runnable）：无反应，需要在线程任务中主动判断。  
（2）等待（Waiting/timed_Waiting）：重置中断状态，会抛出InterruptedException。  
（3）阻塞（Blocked）：无反应。
**线程状态对**


## 参考
（1）、中断：CPU接收到中断请求时，会在正在运行的程序和发起中断请求的程序之间进行一次上下文切换。  
（2）、协程：一个线程可以包含多个协程；线程的上下文切换是由系统控制的；而协程的上下文切换由自己控制，当前协程切换到其它协程由当前协程控制。  
[参考](https://baike.baidu.com/item/协程/8652240?fr=aladdin)  
（3）、用户态切换：有的CPU指令非常危险，错误使用会导致系统崩溃，所以CPU指令被区分特权指令和非特权指令。内核空间（核心软件）能调用特权指令，用户空间  
（普通程序）只能调用非特权指令；当应用程序涉及系统调用时（切换为内核态），先保存用户空间执行的任务，内核空间处理后加载任务继续执行（切换为用户态）。  
[参考](https://blog.csdn.net/weixin_37990128/article/details/109561118)
（4）、系统调用：应用程序在运行时需要系统调用的时候，就会涉及用户态的切换；因为用户态切换涉及任务的保存和加载，所以性能开销较大。  




# 二、Java并发机制底层实现原理
## 2.1 volatile底层
处理器运行背景介绍：为了提高CPU的处理速度，在CPU和内存之间会存在CPU高速缓存（L1、L2、L3，读写速度递减，距离CPU的距离递增），高速缓存的读  
写速度比内存快很多，CPU会先将数据从内存读取到高速缓存中再进行操作。执行写操作后，更新后值也是存在高速缓存，并没有及时刷新到内存中；当高速缓  
存空间不够时，才会将高速缓存中的值刷新到内存中。  
并发问题：每个CPU缓存都可以缓存来自内存的同一份数据，所以当没有同步控制时，刷回内存的结果可能会和预期的不一样。  
volatile底层原理：添加volatile关键字后的代码，在编译为汇编代码后会在对应的变量前加上"Lock"前缀指令，"Lock"前缀指令在多核处理器时会引发以下两件事。  
（1）将当前处理器缓存变量刷回内存；  
（2）使其它CPU缓存中的变量无效，间接导致读的时候需要重新去主内存读取新的变量值。

## 2.2 synchronized的实现原理与应用
synchronized：使用monitor机制，基于monitorenter指令和monitorexit指令实现同步。执行一次monitorenter锁计数器加1，执行一次monitorexit锁的计数器减1；  
实现可重入。

（1）、Java Monitor机制：每一个对象都会关联一个Monitor监视器，这个Monitor监视器是JVM自动添加的。代码执行到monitorenter指令时，尝试获取monitor对象的所有  
权（锁），获取成功后进入临界区（安全）；线程获取锁失败时，会被存入monitor对象的同步队列，synchronizeQueue；当持有锁的线程执行指令monitorexit后，会唤醒  
synchronizeQueue队列中的线程，唤醒的线程竞争获取锁。  
[流程参考](./resources/monitor流程图.png)  
（2）、[monitor对象参考](https://www.cnblogs.com/webor2006/p/11442551.html)

## 2.3 处理器如何实现原子操作
### 处理器实现原子操作
（1）、总线锁保证原子性：总线锁会阻止其它处理器请求，由当前处理器独占共享内存。  
（2）、通过缓存锁定保证原子性：缓存刷回内存的时候，因为"缓存一致性机制"，有两个以上处理器缓存了内存区域数据时，有处理器回写被锁定的缓存行数据时，会使缓存行无效。

### Java实现原子操作
Java可以使用"循环CAS"操作和锁实现原子操作。  
CAS描述：内存中变量的值是当前值，使用一个期望值和当前值进行比较，如果一致则修改成功，否则修改失败。
CAS操作是使用处理器提供的CMPXCHG指令实现的，CAS有如下缺陷  
ABA问题；  
循环时间长的会产生执行开销；  
只能保证一个共享变量的原子操作；jdk1.5以后可以使用AtomicReference类保证引用对象直接的原子性，可以把多个变量放到一个对象进行CAS操作。





# 三、 Java内存模型（JMM）
## 3.1 内存模型定义
所有的变量都存储在主内存，每一线程都有自己的工作内存；工作内存保存的是线程用到的拷贝的主内存的变量副本，线程不能直接读写主内存；使用工作内存进行"传递"；  
线程之间的变量传递需要经过主内存。

## 3.2 Java内存8种基本操作
lock（锁定）用于主内存，标识变量被线程独占（）锁定；  
unlock（解锁）：用于主内存，释放被锁定的变量；  
read（读取）：从主内存把"变量的值"读取到工作内存；  
load（载入）：把read操作读取的值存入工作内存的变量副本；  
use（使用）：将工作内存的变量值传递给执行引擎（使用变量的指令）；  
assign（赋值）：将从执行引擎接受到的值赋值给工作内存的变量（赋值指令）；  
store（存储）：把工作内存变量的值传递给主内存；  
write（写入）：把store操作传递的值存入主内存变量中。

## 3.3 操作规则
（1）、read和load、store和write不允许单独出现；  
（2）、变量的值如果没有经过assign，不允许同步回主内存；assign操作过的值必须同步回主内存；  
（3）、变量只能诞生于主内存；  
（4）、同一变量、同一时刻只能被一个线程执行lock；允许重复操作lock和unlock次数必须一致；  
（5）、lock时会清空工作内存变量值，重新去主内存载入；unlock必须把变量同步回主内存。

## 3.4 volatile变量的特殊规则
概述：volatile变量的操作生成汇编代码后，在执行引擎赋值（assign）操作之后会多执行一个“lock addl $0x0，（%esp）”操作；  
这个操作相当于一个内存屏障，内存屏障可以阻止后面的指令重排序屏障之前。其中前缀lock指令保障了线程可见性。

(1)、保证所有线程可见性 [可见性原理](#21-volatile底层)
(2)、禁止**指令**重排序 [重排序](#21-volatile底层)

## 3.5 重排序
概述：处理器分为编译器重排序、处理器重排序（包含指令重排序）；重排序可能会导致多线程  
**内存可见性问题（线程修改共享变量后，还未同步到主内存，导致其它线程读取的是旧的值）**。  
编译器重排序由编译器自身排序规则限定，指令重排序是通过插入内存屏障实现禁止。

## 3.6 happens-before(先行发生)原则
概述：单纯依赖volatile和synchronized保障有序性太复杂，因此Java提供了一揽子happens-before（先行发生）原则，如果程序执行
不满足happens-before，则可能存在竞争、线程安全问题。  
(1)、程序次序规则：同一个线程，前面的代码先于后面的代码执行；  
(2)、管程锁定规则：unlock先于lock执行；  
(3)、volatile变量：对于变量的写先于后面对变量的读；  
(4)、传递性：A先于B，B先于C，那么A先于C。


# 四、Java线程
概述：Java线程映射的是操作系统的轻量级进程，在Windows、Linux平台映射关系是一对一。轻量级线程由内核线程支持，所以轻量级线程的创建、同步等操作，  
都涉及系统调用，代价较高；这也是synchronized重的原因。  
线程调度：线程调度分抢占式调度（线程自身控制调度）、协同式调度（系统控制调度）；

## 4.1 线程状态
新建（new）；  
运行（runnable）：可能正在运行，也可能在等待系统分配时间片；  
等待（waiting）：无法被系统分配时间片，需要被其它线程唤醒Object.wait()，LockSupport.part()，Thread.join()；  
超时等待（timed waiting）：无法被分配时间片，时间范围内未被其它线程唤醒，超时后会被系统自动唤醒；超时的wait、join方法，LockSupport.partNaons()  
阻塞（Blocked）：阻塞，在使用synchronized无法获取锁时，会被阻塞。Java也仅仅是在使用synchronized是能产生阻塞状态。

### 参考
(1)、等待和阻塞的区别：  
线程是主动进入等待状态，阻塞是被动获取不到锁产生的；  
等待是由其它线程唤醒或超时系统唤醒，阻塞只能等待锁资源的释放。  
(2)、monitor机制和等待：  
产生等待的途径有wait、LockSupport；wait只能和synchronized一起使用，和[monitor机制](#22-synchronized的实现原理与应用)中的等待队列相关。  
LockSupport是调用来本地方法，底层使用Posix的mutex，condition来实现的阻塞唤醒。
(3)、[线程转换图](./resources/线程状态转换.jpg)

## 4.2 锁优化
(1)、自旋锁：避免上下文切换，但是占用了CPU时间，默认自旋次数10  ；
(2)、锁消除：既时编译器在在编译时，发现不存在共享数据竞争，会消除锁；  
(3)、锁粗化：连续对同一个对象加锁，甚至在循环体加锁，会扩大锁同步范围；  
(4)、轻量级锁；将markword中的数据CAS拷贝到线程栈帧中的Lock Record，然后更新markword为指向Lock Record的指针。CAS失败后判断markword是否指向当前线程  
的Lock Record，是则已经拥有锁；否则锁已被抢占，当前线程刮起。当"两条以上"的线程竞争时，会升级为重量级锁，markword存储指向重量级锁的指针。  
(5)、偏向锁：开启偏向锁后，线程A获取锁后会在对象头存储当前线程ID，下次获取锁时直接比较线程ID。出现锁竞争会撤销偏向然后恢复到未锁定状态、或升级为轻量级锁。  
(6)、重量级锁：[synchronized](#22-synchronized的实现原理与应用)。

markword：对象头的markword：默认存储hashCode、分代年龄、锁标记，运行时markWord存储的数据会根据锁的变化而变化。