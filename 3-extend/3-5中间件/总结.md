# 一、消息消费push和pull比较
## push模式
优势：实时。  
劣势1：无法即时感知消费端的消费能力，如果消息的生产能力大于消费能力会导致消费端的消息堆积；  
严重的可能导致消费端服务崩溃。（可以根据消费端的消费能力做流控）  
劣势2：需要维护每次消息传输状态，传输是吧需要重试。

## pull模式
优势1：消费端根据自己的消费能力灵活调整消息拉取量。  
优势2：消息传输失败重新拉取就行，不要保留状态。

劣势1：消息拉取不实时，频率太高会给予服务节点太大压力，频率太低，消息延迟会变高。  
（腾讯的CMQ里有一套长轮询的解决方案，就是取数据时要是没有数据可消费，不是直接返回而是连接等待，一直有数据来了再返回）



# 消息中间件比较

## 1、吞吐量
rabbitMQ：基于AMQP协议的，消息通过交换器投递到队列；因为队列只有一个master处理命令，所以有性能瓶颈，吞吐量较低。
Kafka：Kafka因为采用了多分区的设计方式，吞吐量会因为分区数量的增加而提升；但是当同一个broker的分区数量过多后，
因为Kafka采用的是磁盘顺序读，分区太多会导致磁盘顺序读降级为随机读，会降低其性能。

## 2、顺序性
### 生产端顺序保障
rabbitMQ：无法保障顺序，如果第一批消息投递发送超时、中断，第二批消息投递成功，第一批消息补偿发送导致消息错序。
Kafka：可以保障顺序，可以通过配置实现每次只投递一批消息，成功以后才能投递第二批，可以保障顺序性，但是吞吐量会受到影响。

总结：顺序性和吞吐量二选一。

### 消费端顺序保障
rabbitMQ：比如rabbitMQ消息在消费时可以拒绝，并重新投递到队列，自然就破坏了顺序性。
Kafka：Kafka是顺序追加的磁盘文件，一个分区只能属于同一组内一个消费者，所以单分区可以保障顺序消费；
如果想实现整个topic都是顺序消费，可以将topic的分区数设为1。

总结：顺序性可以理解为单队列同步消费，如果中间某个消息出现问题会影响整个队列的消费。

## 3、消息丢失
### 生产端消息丢失
都可以使用事务、和消息发送确认机制保障消息不丢失。

### 服务节点消息丢失
rabbitMQ：因为rabbitMQ是基于内存的，消息的持久化到磁盘时并不是每一条消息都会及时持久化，  
使用了镜像队列可以一定程度避免这个问题，但是当所有的镜像节点都同时挂掉，有可能导致消息丢失。

Kafka：因为本身就是基于磁盘保存的消息文件，不会发生消息丢失。

总结：既然磁盘顺序读写效率高，为什么rabbitMQ不使用磁盘顺序读，因为rabbitMQ是基于AMQP协议
的，支持延迟队列、死信队列等功能，而支持这些功能需要对消息进行频繁的遍历，读取，比如判断消息
的TTL（过期时间），如果是基于磁盘的那么频繁的IO操作会影响性能，而基于内存的及时是随机读也有
一定的性能保障。

### 消费端消息丢失
使用消费确认机制避免消息丢失。  
如果是批量拉取消息，消费者在消费一部分后宕机，此时提交位移、ack确认的话会出现消息丢失，
如果不确认，会导致重复消费。重复消费可以使用递增序列号去避免，也可以保证消费接口的幂等
避免。

总结：消息丢失比重复消费问题更严重，重复消费可以处理。

## 4、CAP保障
### 一致性
rabbitMQ是master队列处理命令，Kafka是leader分区负责读写，所以都能保障一致性。

### 可用性
rabbitMQ：使用镜像集群模式保证高可用，镜像是基于主从模式做的可用性保障，由master队列节点处理命令；  
并将消息同步到镜像队列。

Kafka：采用多分区，分区多副本的设计保障可用性，分区的leader副本负责读写请求，follower负责同步数据。

总结：Kafka采用了多分区，对于同一个topic把风险分散了，可用性更强。







