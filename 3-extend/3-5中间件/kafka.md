# 一、Kafka基础

## 简介

## 相关概念
### 生产者
生产消息发送到broker，消息发送会经过如下步骤：  
（1）拦截器；  
（2）序列化器；  
（3）分区器：解析消息发往的分区；  
（4）消息累加器：为每一个分区维护一个队列，对消息进行批量包装（Batch），批量发送提高吞吐量；  
（5）sender（发送线程）：发送消息，并缓存向Broker发送后未收到响应的请求（默认5个）；缓存的  
请求数越多说明broker负载越大，所以应该趋向于使用缓存小的Broker发送消息。

### 消费者
消费者和分区绑定，一个消费者可以绑定多个分区；但是同一个消费组内一个分区只能绑定一个消费者。

### 消费组
逻辑概念，一个消费者只能隶属于一个消费组；Kafka消息是基于消费组进行广播的（每一个订阅topic的消费组都能收到消息）。

### broker
Kafka服务节点，集群中会有一个broker被选举为控制器；通过向zk创建临时节点竞争成为控制器。  
控制器对所有的topic、partition进行管理；并监听zookeeper，当zk新增topic、分区、broker等  
信息时，控制器会收到zk通知，然后再由控制器去通知集群中的其它broker。

补充：早期Kafka集群中所有的broker都向zk注册分区、副本变更的监听；导致数据变更后会通知所有  
的broker（羊群效应），而且broker集群出现网络分区会产生脑裂。所以现在只有控制器节点去zk注册  
分区、副本变更事件。


### zookeeper
（1）管理Kafka元数据，比如topic、分区、副本，以及他们之间的关系；控制器选举成功后还需要从  
zk同步分区等数据。  
（2）控制器选举。

### topic
主题是逻辑上的概念，一个主题可以细分为不同的分区；同一个主题下不同的分区保存的消息不一样。

### partition
分区在存储层面是一个可追加的日志文件（log），消息追加到log都会分配一个特定的偏移量（offset）；  
Kafka使用offset保证**分区内的顺序性**。

leader负责读写，follower只负责同步数据。
所有的partition集合叫AR，和leader保持一定程度同步的集合称为ISR，同步滞后过多的副本集合称为OSR。  
LEO（log ebd offset）：每个分区最后一个消息的偏移量+1。  
HW（高水位）：ISR集合中LEO最小的那个副本的LEO就是HW值；消费者只能消费HW之前的消息。

优先副本：AR集合第一个副本。






1、顺序消费
Kafka保证同一分区的消息的顺序消费
2、幂等
日志记录；
业务场景添加消息的唯一ID，通过消费的时候，业务处理成功后才提交；如果消息的ID已经处理过，则不再消费。

3、消息丢失
发送端消息丢失（follower节点未同步，leader挂掉），可以使用发送端的确认机制避免。
消费端消息丢失（消息未处理，自动提交位移），关闭位移自动提交。

4、Kafka死信队列
Kafka本身不支持死信队列；可以自己实现相关功能；
当消息处理失败后，将消息投递到重试topic1并添加重试次数的属性；
消费者也订阅topic1，然后每次处理消息时把重试次数加1；
当重试次数达到约定值时，将消息持久化。

5、Kafka如何保证高性能
（1）基于磁盘的顺序读写；
（2）页缓存：读数据时候先读内存缓存，有直接返回，没有则去磁盘读取然后保存在内存；  
写的时候先写到页缓存，页缓存满了后系统调用（flush、pdflush等）会自动把页缓存刷回磁盘。  
系统调用刷回磁盘是有延迟的，所以如果这段时间broker挂了，有可能导致页缓存数据丢失。  
所以Kafka也提供了同步刷盘的方法，但是同步刷盘会导致吞吐量降低。

**一般不使用同步刷盘机制避免消息丢失，partition本身一主多从也是为了保证可靠性。开发者需要在**  
**吞吐量和可靠性直接做权衡。**


（3）零拷贝：send file（系统调用），常规的IO读调用需要将数据从磁盘copy to系统内核，
系统内核copy to应用内存；写的时候还需要将数据从应用内存copy to内核，最后再从内核copy到网卡；
零拷贝是指将数据直接copy到网卡设备。减少了内核、用户空间的切换，数据copy次数。

6、分区分配策略
（1）消费者和分区进行整除计算，尽量保证均匀。
（2）

7、提高消费效率
（1）如果消费者少于队列，可以多创建几个消费者；保证一个消费者对应一个队列；  
（2）如果速度还是不够，那么消费端可以开启多线程消费；但是多线程消费的位移提交、顺序控制太复杂；  
一般不建议使用。

8、时间轮
时间轮是一个存储定时任务的环形队列；时间轮的格数是固定的wheelSize表示，基本时间跨度为tickMs，  
总体时间跨度interval=tickMs * wheelSize。时间轮的每个节点都维护一个TimerTaskList任务列表。  
若cur时刻插入一个定时n刻度的任务，那么这个任务会保存在 cur + n刻度的TimerTaskList任务列表中。

单层时间轮因为"容量"原因无法处理溢出时间轮的任务；所以时间轮引入层级时间轮处理更长周期的任务。

